# Assembler Directives Documentation

## Executive Summary

The Continuum 93 assembler supports several compiler directives that control code generation, memory layout, and file inclusion. Directives are prefixed with `#` and processed during the assembly phase before code generation.

## Directive Format

All directives start with `#` followed by the directive name (case-insensitive). Arguments follow the directive name, separated by spaces.

```
#DIRECTIVE <arguments>
```

## Supported Directives

### #ORG - Set Origin Address

**Purpose**: Sets the memory address where subsequent code and data will be assembled.

**Syntax**:
```
#ORG <address>
```

**Parameters**:
- `<address>`: 24-bit address (hexadecimal, decimal, or label) where assembly should continue

**Behavior**:
- Sets the global address pointer to the specified address
- If no address is provided, uses the current global address pointer
- If `#RUN` has not been set, automatically sets the run address to the ORG address
- Creates a new code block at the specified address
- Multiple `#ORG` directives can be used to create separate code blocks

**Examples**:
```
#ORG 0x080000       ; Start assembly at address 0x80000
#ORG 0              ; Start assembly at address 0
#ORG .DataSection   ; Start assembly at label address
```

**Implementation Details**:
- The assembler maintains a `GlobalAddressPointer` that tracks the current assembly position
- Each `#ORG` directive creates a new code block managed by `CodeBlockManager`
- Code blocks allow programs to be assembled at different memory locations

### #RUN - Set Execution Start Address

**Purpose**: Specifies the memory address where program execution should begin.

**Syntax**:
```
#RUN <address>
```

**Parameters**:
- `<address>`: 24-bit address (hexadecimal, decimal, or label) where execution should start

**Behavior**:
- Sets the run address (entry point) for the program
- If `#RUN` is not specified, the first `#ORG` address is used as the run address
- If `#RUN` is specified after `#ORG`, it overrides the automatic run address from `#ORG`
- The run address is stored in the compiled program metadata

**Examples**:
```
#RUN 0x080000       ; Start execution at address 0x80000
#RUN .Start         ; Start execution at label .Start
```

**Implementation Details**:
- The run address is stored in `AssemblerStats.RunAddress`
- If `RunFromOrg` is true, a later `#RUN` directive will override it
- The CPU's Instruction Pointer (IPO) is initialized to the run address when the program starts

### #DB - Define Bytes

**Purpose**: Emits byte data directly into the assembled output.

**Syntax**:
```
#DB <arguments>
```

**Parameters**:
- `<arguments>`: Comma-separated list of values, strings, labels, or repetition macros

**Supported Argument Types**:

1. **Numeric Values**:
   - Decimal: `100`, `255`
   - Hexadecimal: `0xFF`, `0x00`
   - Binary: `0b11111111`
   - Negative numbers: `-1`, `-0x10`
   - Underscores allowed for readability: `0xFF_00`, `1_000_000`

2. **Floating-Point Values**:
   - Float: `3.14`, `0.5f`, `-1.5`
   - Stored as IEEE 754 single-precision (4 bytes)

3. **String Literals**:
   - ASCII strings: `"Hello, World!"`
   - Null-terminated automatically
   - Empty string: `""` (emits no bytes)

4. **Labels**:
   - Absolute labels: `.LabelName`
   - Emits the 24-bit address of the label (3 bytes, big-endian)
   - Labels are resolved after the first pass

5. **Repetition Macros**:
   - Format: `[<count>] <value>`
   - Repeats the value a specified number of times
   - Examples:
     - `[100] 0` - 100 zero bytes
     - `[0x800] 0` - 2048 zero bytes
     - `[32] 0xFF` - 32 bytes of 0xFF

**Behavior**:
- Emits bytes sequentially at the current assembly address
- Updates the global address pointer by the number of bytes emitted
- Labels in `#DB` arguments are resolved after all labels are defined (second pass)
- Multiple arguments are processed left-to-right

**Examples**:
```
#DB 0x00, 0x01, 0x02, 0x03    ; Four bytes: 0x00, 0x01, 0x02, 0x03
#DB "Hello", 0                ; String "Hello" with null terminator
#DB .MyLabel                   ; 24-bit address of .MyLabel (3 bytes)
#DB 3.14                       ; Float value (4 bytes)
#DB [100] 0                    ; 100 zero bytes
#DB 0xFF, 0x00, 0b11110000    ; Mixed formats
```

**Implementation Details**:
- `#DB` arguments are parsed by `DBArgument` class
- Arguments are processed in order, each generating byte data
- Label values are refreshed after label resolution (second pass)
- The `Data` list in `CLine` contains the generated bytes

### #INCLUDE - Include External File

**Purpose**: Includes the contents of another assembly file into the current file.

**Syntax**:
```
#include <filepath>
#include "filepath"
```

**Parameters**:
- `<filepath>`: Path to the file to include (relative or absolute)

**Behavior**:
- Reads the specified file and inserts its contents at the include location
- Supports both `<>` and `""` path delimiters (both are treated identically)
- Paths are resolved relative to the current file's directory
- Prevents duplicate includes (same file included multiple times is skipped with a warning)
- Included files are processed recursively (included files can include other files)
- File contents are inserted before the current file's remaining lines

**Path Resolution**:
- If path is not absolute, it's resolved relative to the directory of the file containing the `#include`
- Cross-platform path handling (converts `\` to `/` as needed)
- Case-sensitive file matching

**Examples**:
```
#include "includes\video.asm"           ; Include from subdirectory
#include ..\..\lib\c93-keyboard.asm     ; Include from parent directories
#include <common\utils.asm>             ; Alternative syntax
```

**Implementation Details**:
- `#include` is processed during source line preprocessing in `Interpret.GetFullSourceLines()`
- Included files are tracked in `includeFiles` list to prevent duplicates
- File contents are read and split into lines, then inserted into the source
- The assembler processes the combined source as a single file

**Error Handling**:
- If file is not found: Error logged, compilation continues
- If file already included: Warning logged, file skipped
- File read errors: Error logged, compilation continues

## Directive Processing Order

1. **Preprocessing Phase** (`#INCLUDE`):
   - All `#include` directives are processed first
   - Files are included and merged into a single source

2. **First Pass** (Label Collection):
   - All labels are collected and assigned addresses
   - `#ORG` directives update the address pointer
   - `#DB` directives advance the address pointer

3. **Second Pass** (Code Generation):
   - `#ORG` directives set code block addresses
   - `#RUN` directives set execution start address
   - `#DB` directives emit byte data
   - Labels in `#DB` are resolved to addresses

## Code Block Management

Multiple `#ORG` directives create separate code blocks:

```
#ORG 0x000000       ; Code block 0 at address 0
    LD A, 1
    RET

#ORG 0x080000       ; Code block 1 at address 0x80000
    LD A, 2
    RET
```

Each code block:
- Has its own origin address
- Is assembled independently
- Can be loaded at different memory locations
- Is managed by `CodeBlockManager`

## Label Resolution in Directives

Labels can be used in `#DB` directives:

```
#ORG 0x10000
.MyLabel
    LD A, 1

#ORG 0x20000
    #DB .MyLabel    ; Emits 0x00, 0x01, 0x00 (24-bit address of .MyLabel)
```

Label resolution:
- Labels are resolved after all labels are defined (second pass)
- Absolute labels emit their 24-bit address (3 bytes, big-endian)
- If a label is not found, an error is logged

## Usage Examples

### Complete Program Example

```
#include "lib\keyboard.asm"    ; Include keyboard library

#ORG 0x080000                  ; Start assembly at 0x80000
#RUN .Start                    ; Execution starts at .Start

.Start
    LD A, 0x02
    LD B, 3
    INT 0x01, A                ; Set video pages
    RET

.DataSection
    #ORG 0x20000               ; Data section at different address
    
.StringData
    #DB "Hello, World!", 0
    
.NumberData
    #DB 0x01, 0x02, 0x03, 0x04
    
.FloatData
    #DB 3.14, 2.71
    
.LabelRef
    #DB .Start                 ; Address of .Start (3 bytes)
    
.Buffer
    #DB [1024] 0               ; 1KB zero-filled buffer
```

### Multiple Code Blocks

```
#ORG 0x000000                  ; ROM code
.Init
    LD A, 0
    RET

#ORG 0x080000                  ; RAM code
.Main
    CALL .Init
    RET

#ORG 0x20000                   ; Data section
.Data
    #DB "Data here", 0
```

## Best Practices

1. **Always use `#ORG`** at the start of your program to set the assembly address
2. **Use `#RUN`** to explicitly set the entry point if different from the first `#ORG`
3. **Use `#INCLUDE`** for reusable code libraries and common definitions
4. **Use `#DB`** for data tables, strings, and initialized memory
5. **Use repetition macros** `[N] value` for large zero-filled buffers
6. **Place data in separate sections** using multiple `#ORG` directives for better organization

## Conclusion

The Continuum 93 assembler directives provide flexible control over code generation, memory layout, and file organization. Understanding these directives is essential for writing well-structured assembly programs.

