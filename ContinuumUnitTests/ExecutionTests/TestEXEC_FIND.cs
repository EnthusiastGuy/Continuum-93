using Continuum93.Emulator.Interpreter;
using Continuum93.Emulator;

namespace ExecutionTests
{

    public class TestEXEC_FIND
    {
        [Fact]
        public void TestEXEC_FIND_IrrrI_n_success()
        {
            Assembler cp = new();
            using Computer computer = new();

            computer.CPU.FLAGS.ResetAll();

            computer.LoadMemAt(1000, new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 70, 1, 1, 1, 1, 1 });

            cp.Build(@"
                LD ABC, 1000
                FIND (ABC), 70
                BREAK
            ");

            byte[] compiled = cp.GetCompiledCode();

            computer.LoadMem(compiled);
            computer.Run();

            Assert.Equal(1008, (long)computer.CPU.REGS.ABC);
            TUtils.IncrementCountedTests("exec");
        }

        [Fact]
        public void TestEXEC_FIND_IrrrI_n_fail()
        {
            Assembler cp = new();
            using Computer computer = new();

            computer.CPU.FLAGS.ResetAll();

            computer.LoadMemAt(1000, new byte[] { 1, 1, 1, 1, 1, 1, 1, 1, 70, 1, 1, 1, 1, 1 });

            cp.Build(@"
                LD ABC, 1000
                FIND (ABC), 75
                BREAK
            ");

            byte[] compiled = cp.GetCompiledCode();

            computer.LoadMem(compiled);
            computer.Run();

            Assert.Equal(0xFFFFFF, (long)computer.CPU.REGS.ABC);
            TUtils.IncrementCountedTests("exec");
        }

        [Fact]
        public void TestEXEC_FIND_IrrrI_InnnI_success()
        {
            Assembler cp = new();
            using Computer computer = new();

            computer.CPU.FLAGS.ResetAll();

            computer.LoadMemAt(10000, new byte[] {
                0x43, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x75, 0x6d, 0x00 });
            computer.LoadMemAt(20000, new byte[] {
                0x50, 0x65, 0x72, 0x68, 0x61, 0x70, 0x73, 0x20, 0x6f, 0x6e,
                0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
                0x6f, 0x73, 0x74, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x65,
                0x73, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x65, 0x61, 0x74,
                0x75, 0x72, 0x65, 0x73, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x69,
                0x6e, 0x75, 0x75, 0x6d, 0x20, 0x70, 0x6f, 0x73, 0x65, 0x73,
                0x73, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65,
                0x20, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x74,
                0x6f, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x20, 0x72,
                0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x20, 0x70, 0x61,
                0x67, 0x65, 0x73, 0x2e, 0x00 });

            cp.Build(@"
                #ORG 0
                LD ABC, 20000
                FIND (ABC), (10000)
                BREAK");

            byte[] compiled = cp.GetCompiledCode();

            computer.LoadMem(compiled);
            computer.Run();

            Assert.Equal(20045, (long)computer.CPU.REGS.ABC);
            TUtils.IncrementCountedTests("exec");
        }

        [Fact]
        public void TestEXEC_FIND_IrrrI_InnnI_fail()
        {
            Assembler cp = new();
            using Computer computer = new();

            computer.CPU.FLAGS.ResetAll();

            computer.LoadMemAt(10000, new byte[] {
                0x43, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x75, 0x6d, 0x00 });
            computer.LoadMemAt(20000, new byte[] {
                0x54, 0x68, 0x69, 0x73, 0x20, 0x76, 0x69, 0x72, 0x74, 0x75,
                0x61, 0x6c, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
                0x20, 0x69, 0x73, 0x20, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74,
                0x6f, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x61, 0x74, 0x20, 0x76,
                0x61, 0x72, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x50, 0x55,
                0x20, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x69,
                0x65, 0x73, 0x2e, 0x00 });

            cp.Build(@"
                #ORG 0
                LD ABC, 20000
                FIND (ABC), (10000)
                BREAK");

            byte[] compiled = cp.GetCompiledCode();

            computer.LoadMem(compiled);
            computer.Run();

            Assert.Equal(0xFFFFFF, (long)computer.CPU.REGS.ABC);
            TUtils.IncrementCountedTests("exec");
        }

        [Fact]
        public void TestEXEC_FIND_IrrrI_IrrrI_success()
        {
            Assembler cp = new();
            using Computer computer = new();

            computer.CPU.FLAGS.ResetAll();

            computer.LoadMemAt(10000, new byte[] {
                0x43, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x75, 0x6d, 0x00 });
            computer.LoadMemAt(20000, new byte[] {
                0x50, 0x65, 0x72, 0x68, 0x61, 0x70, 0x73, 0x20, 0x6f, 0x6e,
                0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d,
                0x6f, 0x73, 0x74, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x65,
                0x73, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x65, 0x61, 0x74,
                0x75, 0x72, 0x65, 0x73, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x69,
                0x6e, 0x75, 0x75, 0x6d, 0x20, 0x70, 0x6f, 0x73, 0x65, 0x73,
                0x73, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65,
                0x20, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x74,
                0x6f, 0x20, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x20, 0x72,
                0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x20, 0x70, 0x61,
                0x67, 0x65, 0x73, 0x2e, 0x00 });

            cp.Build(@"
                #ORG 0
                LD ABC, 20000
                LD DEF, 10000
                FIND (ABC), (DEF)
                BREAK");

            byte[] compiled = cp.GetCompiledCode();

            computer.LoadMem(compiled);
            computer.Run();

            Assert.Equal(20045, (long)computer.CPU.REGS.ABC);
            TUtils.IncrementCountedTests("exec");
        }

        [Fact]
        public void TestEXEC_FIND_IrrrI_IrrrI_fail()
        {
            Assembler cp = new();
            using Computer computer = new();

            computer.CPU.FLAGS.ResetAll();

            computer.LoadMemAt(10000, new byte[] {
                0x43, 0x6f, 0x6e, 0x74, 0x69, 0x6e, 0x75, 0x75, 0x6d, 0x00 });
            computer.LoadMemAt(20000, new byte[] {
                0x54, 0x68, 0x69, 0x73, 0x20, 0x76, 0x69, 0x72, 0x74, 0x75,
                0x61, 0x6c, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
                0x20, 0x69, 0x73, 0x20, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x74,
                0x6f, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x61, 0x74, 0x20, 0x76,
                0x61, 0x72, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x50, 0x55,
                0x20, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x69,
                0x65, 0x73, 0x2e, 0x00 });

            cp.Build(@"
                #ORG 0
                LD ABC, 20000
                LD DEF, 10000
                FIND (ABC), (DEF)
                BREAK");

            byte[] compiled = cp.GetCompiledCode();

            computer.LoadMem(compiled);
            computer.Run();

            Assert.Equal(0xFFFFFF, (long)computer.CPU.REGS.ABC);
            TUtils.IncrementCountedTests("exec");
        }
    }
}
